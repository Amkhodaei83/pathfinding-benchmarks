package model;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Shared map configuration storage for consistent benchmarking.
 * Stores map seeds so both BenchmarkRunner and MLBenchmarkRunner use identical maps.
 * Persists maps to disk so they survive JVM restarts.
 */
public class SharedMapConfig {
    
    private static final String PERSISTENCE_FILE = "final_output/map_configs.txt";
    
    /**
     * Represents a map configuration with its seed.
     */
    public static class MapConfig {
        public final int size;
        public final Difficulty difficulty;
        public final int iteration; // 1-indexed iteration number
        public final long seed;
        public final String mapId;
        public final double optimalCost; // Ground truth cost
        
        public MapConfig(int size, Difficulty difficulty, int iteration, long seed, String mapId, double optimalCost) {
            this.size = size;
            this.difficulty = difficulty;
            this.iteration = iteration;
            this.seed = seed;
            this.mapId = mapId;
            this.optimalCost = optimalCost;
        }
        
        public String getKey() {
            return size + "_" + difficulty.name() + "_" + iteration;
        }
        
        /**
         * Serializes this config to a string format: size|difficulty|iteration|seed|mapId|optimalCost
         */
        public String serialize() {
            return size + "|" + difficulty.name() + "|" + iteration + "|" + seed + "|" + mapId + "|" + optimalCost;
        }
        
        /**
         * Deserializes a config from a string format.
         */
        public static MapConfig deserialize(String line) {
            String[] parts = line.split("\\|");
            if (parts.length != 6) {
                return null;
            }
            try {
                int size = Integer.parseInt(parts[0]);
                Difficulty difficulty = Difficulty.valueOf(parts[1]);
                int iteration = Integer.parseInt(parts[2]);
                long seed = Long.parseLong(parts[3]);
                String mapId = parts[4];
                double optimalCost = Double.parseDouble(parts[5]);
                return new MapConfig(size, difficulty, iteration, seed, mapId, optimalCost);
            } catch (Exception e) {
                return null;
            }
        }
    }
    
    // Static storage: Key = "size_difficulty_iteration", Value = MapConfig
    private static final Map<String, MapConfig> storedMaps = new HashMap<>();
    private static boolean mapsGenerated = false;
    private static boolean loadedFromFile = false;
    
    /**
     * Loads map configurations from disk if they exist.
     * Should be called at startup before using maps.
     */
    public static void loadFromFile() {
        if (loadedFromFile) {
            return; // Already loaded
        }
        
        File file = new File(PERSISTENCE_FILE);
        if (!file.exists()) {
            loadedFromFile = true;
            return; // No file to load
        }
        
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            int loaded = 0;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty() || line.startsWith("#")) {
                    continue; // Skip empty lines and comments
                }
                MapConfig config = MapConfig.deserialize(line);
                if (config != null) {
                    storedMaps.put(config.getKey(), config);
                    loaded++;
                }
            }
            if (loaded > 0) {
                mapsGenerated = true;
                System.out.println("✓ Loaded " + loaded + " map configurations from " + PERSISTENCE_FILE);
            }
        } catch (IOException e) {
            System.err.println("⚠️  Warning: Could not load map configurations from " + PERSISTENCE_FILE + ": " + e.getMessage());
        }
        loadedFromFile = true;
    }
    
    /**
     * Saves all map configurations to disk.
     */
    public static void saveToFile() {
        File file = new File(PERSISTENCE_FILE);
        File parentDir = file.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs();
        }
        
        try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {
            writer.println("# Map Configuration File");
            writer.println("# Format: size|difficulty|iteration|seed|mapId|optimalCost");
            writer.println("# Generated by BenchmarkRunner");
            writer.println();
            
            // Sort by size, then difficulty, then iteration for readability
            List<MapConfig> sortedConfigs = new ArrayList<>(storedMaps.values());
            sortedConfigs.sort((a, b) -> {
                int cmp = Integer.compare(a.size, b.size);
                if (cmp != 0) return cmp;
                cmp = a.difficulty.name().compareTo(b.difficulty.name());
                if (cmp != 0) return cmp;
                return Integer.compare(a.iteration, b.iteration);
            });
            
            for (MapConfig config : sortedConfigs) {
                writer.println(config.serialize());
            }
            
            writer.flush();
        } catch (IOException e) {
            System.err.println("⚠️  Warning: Could not save map configurations to " + PERSISTENCE_FILE + ": " + e.getMessage());
        }
    }
    
    /**
     * Stores a map configuration for later use.
     * Automatically saves to disk after storing.
     */
    public static void storeMapConfig(int size, Difficulty difficulty, int iteration, long seed, String mapId, double optimalCost) {
        MapConfig config = new MapConfig(size, difficulty, iteration, seed, mapId, optimalCost);
        storedMaps.put(config.getKey(), config);
        // Save to disk immediately to ensure persistence
        saveToFile();
    }
    
    /**
     * Retrieves a stored map configuration.
     * Automatically loads from disk if not already loaded.
     * @return MapConfig if found, null otherwise
     */
    public static MapConfig getMapConfig(int size, Difficulty difficulty, int iteration) {
        if (!loadedFromFile) {
            loadFromFile();
        }
        String key = size + "_" + difficulty.name() + "_" + iteration;
        return storedMaps.get(key);
    }
    
    /**
     * Generates a GridMap from a stored configuration.
     */
    public static GridMap generateMap(MapConfig config) {
        GridMap map = new GridMap();
        map.generateRandom(config.size, config.size, config.difficulty, config.seed);
        return map;
    }
    
    /**
     * Gets all stored map configurations as a list.
     * Automatically loads from disk if not already loaded.
     */
    public static List<MapConfig> getAllMapConfigs() {
        if (!loadedFromFile) {
            loadFromFile();
        }
        return new ArrayList<>(storedMaps.values());
    }
    
    /**
     * Clears all stored map configurations (both in memory and on disk).
     */
    public static void clear() {
        storedMaps.clear();
        mapsGenerated = false;
        loadedFromFile = false;
        File file = new File(PERSISTENCE_FILE);
        if (file.exists()) {
            file.delete();
        }
    }
    
    /**
     * Marks that maps have been generated.
     */
    public static void setMapsGenerated(boolean generated) {
        mapsGenerated = generated;
    }
    
    /**
     * Checks if maps have been generated.
     * Automatically loads from disk if not already loaded.
     */
    public static boolean areMapsGenerated() {
        if (!loadedFromFile) {
            loadFromFile();
        }
        return mapsGenerated || !storedMaps.isEmpty();
    }
    
    /**
     * Gets the number of stored maps.
     * Automatically loads from disk if not already loaded.
     */
    public static int getMapCount() {
        if (!loadedFromFile) {
            loadFromFile();
        }
        return storedMaps.size();
    }
}

