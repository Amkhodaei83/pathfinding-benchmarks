package algorithm;

import model.GridMap;
import model.Node;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

public class MachineLearnedHeuristic implements Heuristic {

    // Path to the file generated by Python
    private final String configFile;

    // Learned Weights (Defaults set to Manhattan behavior just in case file fails)
    private double wManhattan = 1.0;
    private double wEuclidean = 0.0;
    private double wMaintenance = 0.0;
    private double wTraffic = 0.0;
    private double wShortcut = 0.0;
    private double wWall = 0.0;
    private double intercept = 0.0;
    
    private String modelType = "Unknown";

    private boolean modelLoaded = false;
    
    /**
     * Default constructor - uses ml_weights.properties
     */
    public MachineLearnedHeuristic() {
        this("ml_weights.properties");
    }
    
    /**
     * Constructor with custom config file path
     */
    public MachineLearnedHeuristic(String configFile) {
        this.configFile = configFile;
        loadModelWeights();
    }

    // Optimization: Cache the terrain percentages for the current map
    // so we don't re-calculate them for every node in the path.
    private GridMap cachedMap = null;
    private double cachedPctMaintenance = 0.0;
    private double cachedPctTraffic = 0.0;
    private double cachedPctShortcut = 0.0;
    private double cachedPctWall = 0.0;

    private void loadModelWeights() {
        Properties props = new Properties();
        try (FileInputStream fis = new FileInputStream(configFile)) {
            props.load(fis);

            // Load model type (new field)
            this.modelType = props.getProperty("MODEL_TYPE", "LinearRegression");
            
            this.wManhattan   = Double.parseDouble(props.getProperty("W_MANHATTAN", "1.0"));
            this.wEuclidean   = Double.parseDouble(props.getProperty("W_EUCLIDEAN", "0.0"));
            this.wMaintenance = Double.parseDouble(props.getProperty("W_MAINTENANCE", "0.0"));
            this.wTraffic     = Double.parseDouble(props.getProperty("W_TRAFFIC", "0.0"));
            this.wShortcut    = Double.parseDouble(props.getProperty("W_SHORTCUT", "0.0"));
            this.wWall        = Double.parseDouble(props.getProperty("W_WALL", "0.0"));
            this.intercept    = Double.parseDouble(props.getProperty("INTERCEPT", "0.0"));

            this.modelLoaded = true;
            System.out.println("✅ [ML Heuristic] Model weights loaded from " + configFile);
            System.out.println("   Model Type: " + modelType);
            System.out.println("   Weights: M=" + String.format("%.4f", wManhattan) + 
                             ", E=" + String.format("%.4f", wEuclidean) + 
                             ", Maint=" + String.format("%.4f", wMaintenance) +
                             ", Traffic=" + String.format("%.4f", wTraffic) +
                             ", Shortcut=" + String.format("%.4f", wShortcut) +
                             ", Wall=" + String.format("%.4f", wWall) +
                             ", Intercept=" + String.format("%.4f", intercept));

        } catch (IOException e) {
            System.err.println("⚠️ [ML Heuristic] Could not find '" + configFile + "'. Defaulting to standard Manhattan.");
            this.modelLoaded = false;
        } catch (NumberFormatException e) {
            System.err.println("⚠️ [ML Heuristic] Error parsing weights. Check Python output format.");
        }
    }

    /**
     * Caches the terrain percentages for the current map.
     * This runs only ONCE per map to avoid redundant calculations.
     */
    private void updateMapEnvironment(GridMap map) {
        if (map == cachedMap) return; // Optimization: Already calculated for this map

        // Fetch percentages (these are map-level constants, not distance-dependent)
        this.cachedPctMaintenance = map.getPercentMaintenance();
        this.cachedPctTraffic     = map.getPercentHighTraffic();
        this.cachedPctShortcut    = map.getPercentShortcut();
        this.cachedPctWall        = map.getPercentWall();

        this.cachedMap = map;
    }

    @Override
    public double compute(Node current, Node goal, GridMap map) {
        // 1. Update Map Context (cache terrain percentages)
        updateMapEnvironment(map);

        // 2. Calculate Geometry Features
        double dx = Math.abs(current.x - goal.x);
        double dy = Math.abs(current.y - goal.y);
        double manhattan = dx + dy;
        double euclidean = Math.sqrt(dx * dx + dy * dy);

        // 3. Apply Regression Formula
        // This MUST match exactly what Python trained on:
        // optimal_cost = w1*manhattan + w2*euclidean + w3*pct_maintenance + 
        //                w4*pct_hightraffic + w5*pct_shortcut + w6*pct_wall + intercept
        // 
        // NOTE: Terrain percentages are added directly as features, NOT multiplied by distance!
        double predictedCost = (manhattan * wManhattan) +
                (euclidean * wEuclidean) +
                (cachedPctMaintenance * wMaintenance) +
                (cachedPctTraffic * wTraffic) +
                (cachedPctShortcut * wShortcut) +
                (cachedPctWall * wWall) +
                intercept;

        // 4. Safety Checks
        // Heuristics cannot be negative
        if (predictedCost < 0) return 0;

        // Optional: Maintain Admissibility?
        // If you want strict A*, uncomment the line below to never overestimate too much.
        // return Math.min(predictedCost, manhattan * 10); // Cap at max possible cost

        return predictedCost;
    }


}